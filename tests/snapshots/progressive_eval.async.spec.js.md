# Snapshot report for `tests/progressive_eval.async.spec.js`

The actual snapshot is saved in `progressive_eval.async.spec.js.snap`.

Generated by [AVA](https://avajs.dev).

## async MemberExpression with a ComputedProperty

> Snapshot 1

    'this.nodes[0].transpile(this.nodes[1].transpile(this.external("delayed")(1, this.nodes[3].evaluator({}))),"x" + "y")'

## MemberExpression with an async ComputedProperty

> Snapshot 1

    'this.nodes[0].transpile({xy:this.external("xy")},this.nodes[1].transpile(this.external("delayed")(1, this.nodes[3].evaluator({}))))'

## async CallExpression

> Snapshot 1

    'this.nodes[0].transpile(this.nodes[1].transpile(Math),this.nodes[2].transpile(this.external("delayed")(1, this.nodes[4].evaluator({}))))'

## async CallExpression with this argument

> Snapshot 1

    'this.nodes[0].transpile(this.nodes[1].transpile(this.external("range")(0, 5)),this.nodes[3].transpile(this.external("delayed")(1, this.nodes[5].evaluator({}))))'

## async CallExpression with async callee and spread arguments

> Snapshot 1

    'this.nodes[0].transpile(this.nodes[1].transpile(this.external("delayed")(1, this.nodes[3].evaluator({}))),this.external("range")(1, 3),this.external("range")(4, 6))'

## async CallExpression with async callee and this argument

> Snapshot 1

    'this.nodes[0].transpile(this.nodes[1].transpile(this.nodes[2].transpile(this.external("delayed")(1, this.nodes[4].evaluator({})))),2)'

## async CallExpression with async callee and a chain of properties / calls

> Snapshot 1

    'this.nodes[0].transpile(this.nodes[1].transpile(this.nodes[2].transpile(this.external("delayed")(1, this.nodes[4].evaluator({}))),1,1))'

## o[p](args) with o, p sync but o[p] async resolving to a function

> Snapshot 1

    'this.nodes[0].transpile(this.nodes[1].transpile(({ f: this.nodes[2].transpile(this.external("delayed")(1, this.nodes[4].evaluator({}))) })),8)'

## o[p](args) with o, p sync but o[p] async resolving to a non-function

> Snapshot 1

    'this.nodes[0].transpile(({ f: this.nodes[2].transpile(this.external("delayed")(1, this.nodes[4].evaluator({}))) }).f,0)'

## NewExpression with async constructor

> Snapshot 1

    'this.nodes[0].transpile((this.nodes[1].transpile(this.nodes[2].transpile(this.external("delayed"),1,this.nodes[3].evaluator({})))),3)'

> Snapshot 2

    'this.nodes[0].transpile((this.nodes[1].transpile(this.external("delayed")(1, this.nodes[3].evaluator({})))),3)'

## async sum

> Snapshot 1

    'this.nodes[0].transpile(this.external("sum"),this.external("delayed")(1, [ this.external("delayed")(1, 55), this.external("delayed")(1, 33) ]))'

## race

> Snapshot 1

    'this.nodes[0].transpile(this.nodes[1].evaluator({}),this.external("race")([this.nodes[3].transpile(this.external("delayed")(10, this.nodes[5].evaluator({}))), this.nodes[6].transpile(this.external("delayed")(1, this.nodes[8].evaluator({})))]))'

## that everything else (including .then callbacks) is still transpiled

> Snapshot 1

    'this.nodes[0].transpile(this.nodes[1].evaluator({}),Promise.resolve(42))'
